## redis

### redis 集群的几种实现方式

#### 主从模式

主从复制模式就是部署堕胎redis节点，只有一台节点是主节点master，其他节点都是从节点slave，也叫备份节点replica。只有master节点提供数据的事务性操作(增删改)，然后slave节点只提供读操作。所有slave节点的数据都是从master节点同步过来的，架构如下：

![主从1](image.png)

该图只是最简单的一种主从结构方式，所有的slave节点都挂在master节点上，这样做的好处是slave节点与master节点的数据延迟较小；缺点是如果slave节点数量很多，master同步一次数据的耗时就很长。针对这一问题，可以使用下图中的主从架构：

![Alt text](image-1.png)

全量数据同步一般发生在slave节点初始化阶段，需要将master上的所有数据全部复制过来。全量同步的流程图如下：

1. slave节点根据配置的master节点信息，连接上master节点，并向master节点发送SYNC命令；
2. master节点收到SYNC命令后，执行BGSAVE命令异步将内存数据生成到rdb快照文件中，同时将生成rdb文件期间所有的写命令记录到一个缓冲区，保证数据同步的完整性；
3. master节点的rdb快照文件生成完成后，将该rdb文件发送给slave节点；
4. slave节点收到rdb快照文件后，丢弃所有内存中的旧数据，并将rdb文件中的数据载入到内存中；
5. master节点将rdb快照文件发送完毕后，开始将缓冲区中的写命令发送给slave节点；
6. slave节点完成rdb文件数据的载入后，开始执行接收到的写命令。

以上就是master-slave全量同步的原理，执行完上述动作后，slave节点就可以接受来自用户的读请求，同时，master节点与slave节点进入命令传播阶段，在该阶段master节点会将自己执行的写命令发送给slave节点，slave节点接受并执行写命令，从而保证master节点与slave节点的数据一致性。

#### 哨兵架构

哨兵（sentinel）在Redis主从架构中是一个非常重要的组件，是在Redis2.8版本引入的。它的主要作用就是监控所有的Redis实例，并实现master节点的故障转移。哨兵是一个特殊的redis服务，它不负责数据的读写，只用来监控Redis实例。

在哨兵模式架构中，client端在首次访问Redis服务时，实际上访问的是哨兵（sentinel），sentinel会将自己监控的Redis实例的master节点信息返回给client端，client后续就会直接访问Redis的master节点，并不是每次都从哨兵处获取master节点的信息。

sentinel会实时监控所有的Redis实例是否可用，当监控到Redis的master节点发生故障后，会从剩余的slave节点中选举出一个作为新的master节点提供服务，并将新master节点的地址通知给client端，其他的slave节点会通过slaveof命令重新挂载到新的master节点下。当原来的master节点恢复后，也会作为slave节点挂在新的master节点下。如下图：

![Alt text](image-2.png)

一般情况下，为了保证高可用，sentinel也会进行集群部署，防止单节点sentinel挂掉。当sentinel集群部署时，各sentinel除了监控redis实例外，还会彼此进行监控。如下图：

![Alt text](image-3.png)

### Redis为什么快
#### 基于内存存储实现
我们都知道内存读写是比在磁盘快很多的，Redis基于内存存储实现的数据库，相对于数据存在磁盘的MySQL数据库，省去磁盘I/O的消耗。

#### 高效的数据结构
#### 合理的线程模型
IO多路复用

多路I/O复用技术可以让单个线程高效的处理多个连接请求，而Redis使用用epoll作为I/O多路复用技术的实现。并且，Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

epoll：epoll就是对select和poll的改进了。它的核心思想是基于事件驱动来实现的

poll：poll本质上和select没有区别，依然需要进行数据结构的复制，依然是基于轮询来实现

select：轮询fd_set，以检查出发生IO事件的fd


    什么是IO多路复用
    - I/O ：网络 I/O
    - 多路 ：多个网络连接
    - 复用：复用同一个线程。
    
    IO多路复用其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；而没有文件句柄就绪时,就会阻塞应用程序，交出cpu。

- Redis是单线程模型的，而单线程避免了CPU不必要的上下文切换和竞争锁的消耗。也正因为是单线程，如果某个命令执行过长（如hgetall命令），会造成阻塞。Redis是面向快速执行场景的数据库。，所以要慎用如smembers和lrange、hgetall等命令。
- Redis 6.0 引入了多线程提速，它的执行命令操作内存的仍然是个单线程。


### 缓存穿透
缓存穿透是指客户端请求的数据再缓存中和数据库中都不存在，这样的缓存永远不会生效，这些请求都会打到数据库

解决方案：
- 缓存空对象
实现简单，维护方便

缺点：额外的内存消耗，可能造成短期不一致

- 布隆过滤
内存占用少，没有多余的key

缺点：实现复杂，存在误判的可能

- 增强id复杂度，避免被猜测id规律

- 做好数据的基础格式校验

- 加强用户权限校验

- 做好热点参数的限流

### 缓存雪崩
缓存雪崩是指再同一时段内缓存key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：
- 不同的key的TTL添加随机值
- 利用redis集群提高服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

### 缓存击穿
缓存击穿问题也叫做热点key问题，就是一个高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会再瞬间给数据库带来巨大的冲击。

常见解决方案：
- 互斥锁

- 逻辑过期

![Alt text](./实战篇/image.png)


### 分布式锁
用redis的setnx命令互斥创建  即可完成锁的功能

结束的时候del就行

然后常见的问题就是，要记得设置过期时间，如果无法判断需要运行多长就用一个goroutine延长过期时间

### 什么是热key  如何解决热key问题
什么是热Key呢？在Redis中，我们把访问频率高的key，称为热点key。

如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。

而热点Key是怎么产生的呢？主要原因有两个：

    1. 用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景。
    2. 请求分片集中，超过单Redi服务器的性能，比如固定名称key，Hash落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点Key问题。

那么在日常开发中，如何识别到热点key呢？

    1. 凭经验判断哪些是热Key；
    2. 客户端统计上报；
    3. 服务代理层上报

如何解决热key问题？

    1. Redis集群扩容：增加分片副本，均衡读流量；
    2. 将热key分散到不同的服务器中；
    3. 使用二级缓存，即JVM本地缓存,减少Redis的读请求。

### redis 过期策略和内存淘汰策略
我们在set key的时候，可以给它设置一个过期时间，比如expire key 60。指定这key60s后过期，60s后，redis是如何处理的嘛？我们先来介绍几种过期策略：

#### 定期过期
每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

#### 惰性过期
只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

#### 定期过期
每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。

---
Redis中同时使用了惰性过期和定期过期两种过期策略。

假设Redis当前存放30万个key，并且都设置了过期时间，如果你每隔100ms就去检查这全部的key，CPU负载会特别高，最后可能会挂掉。
因此，redis采取的是定期过期，每隔100ms就随机抽取一定数量的key来检查和删除的。
但是呢，最后可能会有很多已经过期的key没被删除。这时候，redis采用惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且已经过期了，此时就会删除。

---

### AOF 和 RDB 在使用场景上的区别
其实就是异同比较

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

1. RDB的优缺点：

    - 优点：RDB持久化文件，速度比较快，而且存储的是一个二进制文件，传输起来很方便。

     - 缺点：RDB无法保证数据的绝对安全，有时候就是1s也会有很大的数据丢失。

2. AOF的优缺点：

    - 优点：AOF相对RDB更加安全，一般不会有数据的丢失或者很少，官方推荐同时开启AOF和RDB。

    - 缺点：AOF持久化的速度，相对于RDB较慢，存储的是一个文本文件，到了后期文件会比较大，传输困难。

AOF恢复的时候实际上就是执行指令，会比较消耗CPU资源

RDB的话因为是二进制文件，属于快照，然后恢复书店会比较快。

以最常用的互联网行业为例：对于互联网行业中的用户行为数据，因为需要实时访问和修正，建议使用AOF方式进行持久化，由于持久化过程中具有一定的延时，因此在快照备份的情况下，应该适量减少备份周期；对于系统配置数据，由于配置数据相对比较小，使用RDB持久化方式更为合适。